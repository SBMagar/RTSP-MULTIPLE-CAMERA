//***********************************************************
//  RTSP server for combined picture from multiple cameras
//
//  Program written by Jiaxin Du, jiaxin.du@outlook.com
//  All right reserved.
//
//***********************************************************
#include "misc.h"

using std::string;

std::string byte2str(const uint64_t& val)
{
   double rval = static_cast<double>(val);
   char   unit[2] = { '\0', '\0' };
   if (rval > 1073741824.) {
      rval /= (1073741824.);
      unit[0] = 'G';
   }
   else if (rval > 1048576.) {
      rval /= (1048576.);
      unit[0] = 'M';
   }
   else if (rval > 1024) {
      rval /= (1024.);
      unit[0] = 'K';
   }

   char buff[32];
   snprintf(buff, 32, "%g%s", int(rval * 100 + 0.5) / 100., unit);
   return std::string(buff);
}

// convert x to a string
std::string double2str(const double& val, const char* format)
{
   char buff[32];
   snprintf(buff, 32, format, val);
   return std::string(buff);
}

///@param val the variable to be converted
///@param digit number of digit will be generated
///
///   convert `val` to a string, if the width is less than digit
///   zero will be padded to the front of the string
///   for example:
///      int2str(19, 3) => "019" \n
///      int2str(119, 2) => "119" \n
string int2str(const int& val, const int& digit)
{
   char buff[16];
   int len = snprintf(buff, 16, "%d", val);

   if (len < digit && digit < 16) {
      return string(digit - len, '0') + string(buff);
   }
   else {
      return string(buff);
   }
}

//   Convert the string to a number. If no such
//   conversion is available, the function returns false
bool str2byte(const string &str_in, uint64_t &val)
{
   char *pend = nullptr;

   double rval = std::strtod(str_in.c_str(), &pend);

   if (rval < 0) return false;

   //skip space
   while (isspace(*pend)) {
      ++pend;
   }

   if (*pend == 'k' || *pend == 'K') {
      rval *= 1024.;
      ++pend;
   }
   else if (*pend == 'm' || *pend == 'M') {
      rval *= 1024.*1024.;
      ++pend;
   }
   else if (*pend == 'g' || *pend == 'G') {
      rval *= 1024.*1024.*1024.;
      ++pend;
   }

   val = static_cast<uint64_t>(rval);
   return (*pend == 0);
};

//   Convert the string to a number. If no such
//   conversion is available, the function returns false
bool str2double(const string &str_in, double &val)
{
   char *pend = nullptr;

   val = std::strtod(str_in.c_str(), &pend);
   //skip space
   while (isspace(*pend)) {
      ++pend;
   }
   return (*pend == 0);
};

///   convert the string to a integer.
///   If no such conversion is available,
///   the function will return false
bool str2int(const string &str_in, int &val)
{
   char *pend = nullptr;

   val = std::strtol(str_in.c_str(), &pend, 10);
   //skip spaces
   while (isspace(*pend)) {
      ++pend;
   }
   return (*pend == 0);
};

// remove comments from a string
string remove_comments(const string &str_in)
{
   std::string str(str_in);

   std::size_t pos = str.find("/*");
   std::size_t pos2;

   while (pos != string::npos) {
      if ((pos2 = str.find("*/", pos)) != string::npos) {
         str.erase(pos, pos2 + 2);
         pos = str.find("/*");
      }
      else {
         break;
      }
   }

   pos = str.find("//");

   while (pos != string::npos) {
      if ((pos2 = str.find("\n", pos)) != string::npos) {
         str.erase(pos, pos2);
         pos = str.find("//");
      }
      else {
         str.erase(pos);
         break;
      }
   }

   return str;
};

//   remove the leading and ending space from a string
string strtrim(const string &str)
{
   if (!str.empty()) {
      auto it_bgn = str.find_first_not_of(" \t\n\v\f\r");
      auto it_end = str.find_last_not_of(" \t\n\v\f\r");
      if (it_bgn != string::npos && it_end != string::npos && it_end >= it_bgn) {
         return string(str.substr(it_bgn, it_end - it_bgn + 1));
      }
   }
   return string("");
};

// split a string (connected by delim) to an array of string
void strsplit(const string& str, const string& delim, std::vector<string>& parts)
{
   parts.clear();

   if (str.empty()) return;

   std::size_t pre_pos = 0;
   std::size_t pos = str.find_first_of(delim);

   while (pos != string::npos) {
      parts.push_back(str.substr(pre_pos, pos - pre_pos));
      pre_pos = pos + 1;
      pos = str.find_first_of(delim, pre_pos);
   }

   parts.push_back(str.substr(pre_pos));
};

/// Processing parameter setting text,
///    converting to parameter name and value pairs
/// 1. remove comments
/// 2. split grouped parameters
/// 3. remove non-necessary parts in parameter values, including "", {} pairs
/// 4. put the parameter name and value pair in paramList
bool read_param(const char* fileName, std::map <std::string, std::string> &paramList)
{
   std::ifstream fin(fileName);
   std::string buff, str;
   std::string pre_delim;
   std::string paramName, paramVal;

   size_t pos, pos_1, pos_2, pos_3, pos_4;
   int nbracket;
   int lineno = 0;

   std::vector<std::string> parts;

   while (fin.good()) {
      //bracket=false;
      getline(fin, buff);
      ++lineno;
      //use strstrip to remove comments and all spaces
      buff = strtrim(remove_comments(buff));
      if (buff.empty()) continue;
      //test whether this is bracket
      nbracket = 0;
      for (pos = 0; pos < buff.size(); ++pos) {
         if (buff[pos] == '{') ++nbracket;
         else if (buff[pos] == '}') --nbracket;
      }
      if (nbracket < 0) {
         eprintf("brackets do not match!");
         goto RETURN_ERROR;
      }
      else {
         while (nbracket != 0) {
            getline(fin, str);
            ++lineno;
            if (!fin.good() && str.empty()) {
               eprintf("brackets do not match!");
               goto RETURN_ERROR;
            }
            str = strtrim(remove_comments(str));
            buff += str;
            while (pos < buff.size()) {
               if (buff[pos] == '{') ++nbracket;
               else if (buff[pos] == '}') --nbracket;
               ++pos;
            }
         }
      }

      //deal with group parameters
      pos_1 = buff.find_last_of("{");
      while (pos_1 != string::npos) {
         nbracket = 1;
         for (pos_2 = pos_1 + 1; pos_2 < buff.size(); ++pos_2) {
            if (buff[pos_2] == '{') ++nbracket;
            if (buff[pos_2] == '}') --nbracket;
            if (nbracket == 0) break;
         }

         pos_3 = buff.find_first_of("=", pos_1);

         if (pos_3 != string::npos && pos_2 > pos_3) {
            pos_4 = buff.find_last_of(";\n", pos_1);
            if (pos_4 == string::npos) {
               pre_delim = strtrim(buff.substr(0, pos_1));
            }
            else {
               pre_delim = strtrim(buff.substr(pos_4 + 1, pos_1 - pos_4 - 1));
            }

            if (pre_delim.empty()) {
               buff.erase(pos_2, 1);
               buff.erase(pos_1, 1);
               pos_2 -= 1;
            }
            else {
               pre_delim += ".";

               strsplit(buff.substr(pos_1 + 1, pos_2 - pos_1 - 1), ";", parts);

               if (!parts.empty() && !strtrim(parts.back()).empty()) {
                  eprintf("semicolon missing after expression!");
                  goto RETURN_ERROR;
               }

               parts.pop_back();

               for (auto& expr : parts) {
                  expr = strtrim(expr);
                  if (expr.empty()) {
                     eprintf("expression missing before semicolon!");
                     goto RETURN_ERROR;
                  }
               }

               str.clear();

               for (auto & part : parts) {
                  str += (pre_delim + part + ";");
               }

               do {
                  ++pos_2;
               } while (isspace(buff[pos_2]));

               if (buff[pos_2] == ';')
                  ++pos_2;

               if (pos_4 == string::npos) {
                  buff.replace(0, pos_2, str);
                  break;
               }
               else {
                  buff.replace(pos_4 + 1, pos_2 - pos_4 - 1, str);
                  pos_1 = pos_4;
               }
            }
         }
         pos_1 = buff.find_last_of("{", pos_1 - 1);
      }

      //cout<<"[[["<<buff<<"]]]\n";
      strsplit(buff, ";", parts);
      if (!parts.empty() && !parts.back().empty()) {
         eprintf("semicolon missing after expression '%s'!", buff.c_str());
         goto RETURN_ERROR;
      }
      else {
         parts.pop_back();
      }

      for (auto vit = parts.begin(); vit < parts.end(); ++vit) {
         str = strtrim(*vit);
         pos = str.find("=");
         if (pos == string::npos) {
            eprintf("missing '=' in expression '%s'!", str.c_str());
            goto RETURN_ERROR;
         }

         paramName = strtrim(str.substr(0, pos));
         paramVal = strtrim(str.substr(pos + 1));
         if (paramVal.front() == '\"' || paramVal.back() == '\"') {
            paramVal = paramVal.substr(1, paramVal.size() - 2);
         }
         if (paramVal.empty()) {
            eprintf("parameter '%s' has no value!", paramName.c_str());
            goto RETURN_ERROR;
         }

         //add the parameter to the list

         if (paramList.count(paramName) > 0) {
            eprintf("parameter '%s' was set twice!", paramName.c_str());
            goto RETURN_ERROR;
         }

         paramList[paramName] = paramVal;
      }
   }
   fin.close();
   return true;

RETURN_ERROR:
   eprintf("error when processing line %d in parameter text.", lineno);
   eprintf("----------\n%s\n", buff.c_str());
   fin.close();
   return false;
};

void dump_binary(const uint8_t *ptr, int sz)
{
   char buff[192] = { 0 };
   int pos = 0;
   const uint8_t* pend = ptr + sz;
   while (ptr < pend) {
      pos += snprintf(buff + pos, 191L - pos, "%02x ", *ptr);
      if (pos >= 189) {
         printf("%s", buff);
         pos = 0;
         buff[0] = 0;
      }
      ++ptr;
   }
   if (pos > 0)
      printf("%s", buff);
};

unsigned char pixel_array_letters[95][15] = {
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },// space :32
   { 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00 },// ! :33
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x36, 0x36, 0x36, 0x00 },
   { 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0xff, 0x66, 0x66, 0xff, 0x66, 0x66, 0x00, 0x00, 0x00 },
   { 0x00, 0x00, 0x00, 0x18, 0x7e, 0xff, 0x1b, 0x1f, 0x7e, 0xf8, 0xd8, 0xff, 0x7e, 0x18, 0x00 },
   { 0x00, 0x00, 0x00, 0x0e, 0x1b, 0xdb, 0x6e, 0x30, 0x18, 0x0c, 0x76, 0xdb, 0xd8, 0x70, 0x00 },
   { 0x00, 0x00, 0x00, 0x7f, 0xc6, 0xcf, 0xd8, 0x70, 0x70, 0xd8, 0xcc, 0xcc, 0x6c, 0x38, 0x00 },
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x1c, 0x0c, 0x0e, 0x00 },
   { 0x00, 0x00, 0x00, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0c, 0x00 },
   { 0x00, 0x00, 0x00, 0x30, 0x18, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x18, 0x30, 0x00 },
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x99, 0x5a, 0x3c, 0xff, 0x3c, 0x5a, 0x99, 0x00, 0x00, 0x00 },
   { 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0xff, 0xff, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00 },
   { 0x00, 0x00, 0x00, 0x30, 0x18, 0x1c, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
   { 0x00, 0x00, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
   { 0x00, 0x00, 0x60, 0x60, 0x30, 0x30, 0x18, 0x18, 0x0c, 0x0c, 0x06, 0x06, 0x03, 0x03, 0x00 },
   { 0x00, 0x00, 0x00, 0x3c, 0x66, 0xc3, 0xe3, 0xf3, 0xdb, 0xcf, 0xc7, 0xc3, 0x66, 0x3c, 0x00 },
   { 0x00, 0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x38, 0x18, 0x00 },
   { 0x00, 0x00, 0x00, 0xff, 0xc0, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x03, 0xe7, 0x7e, 0x00 },
   { 0x00, 0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0x7e, 0x07, 0x03, 0x03, 0xe7, 0x7e, 0x00 },
   { 0x00, 0x00, 0x00, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0xff, 0xcc, 0x6c, 0x3c, 0x1c, 0x0c, 0x00 },
   { 0x00, 0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0, 0xff, 0x00 },
   { 0x00, 0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc7, 0xfe, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e, 0x00 },
   { 0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0c, 0x06, 0x03, 0x03, 0x03, 0xff, 0x00 },
   { 0x00, 0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e, 0x00 },
   { 0x00, 0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x03, 0x7f, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e, 0x00 },
   { 0x00, 0x00, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00 },
   { 0x00, 0x00, 0x00, 0x30, 0x18, 0x1c, 0x1c, 0x00, 0x00, 0x1c, 0x1c, 0x00, 0x00, 0x00, 0x00 },
   { 0x00, 0x00, 0x00, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x00 },
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00 },
   { 0x00, 0x00, 0x00, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x03, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x00 },
   { 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x18, 0x0c, 0x06, 0x03, 0xc3, 0xc3, 0x7e, 0x00 },
   { 0x00, 0x00, 0x00, 0x3f, 0x60, 0xcf, 0xdb, 0xd3, 0xdd, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00 },
   { 0x00, 0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xff, 0xc3, 0xc3, 0xc3, 0x66, 0x3c, 0x18, 0x00 },
   { 0x00, 0x00, 0x00, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe, 0x00 },
   { 0x00, 0x00, 0x00, 0x7e, 0xe7, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e, 0x00 },
   { 0x00, 0x00, 0x00, 0xfc, 0xce, 0xc7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc7, 0xce, 0xfc, 0x00 },
   { 0x00, 0x00, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xc0, 0xc0, 0xff, 0x00 },
   { 0x00, 0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xc0, 0xff, 0x00 },
   { 0x00, 0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xcf, 0xc0, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e, 0x00 },
   { 0x00, 0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xff, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x00 },
   { 0x00, 0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x00 },
   { 0x00, 0x00, 0x00, 0x7c, 0xee, 0xc6, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x00 },
   { 0x00, 0x00, 0x00, 0xc3, 0xc6, 0xcc, 0xd8, 0xf0, 0xe0, 0xf0, 0xd8, 0xcc, 0xc6, 0xc3, 0x00 },
   { 0x00, 0x00, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0x00 },
   { 0x00, 0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xdb, 0xff, 0xff, 0xe7, 0xc3, 0x00 },
   { 0x00, 0x00, 0x00, 0xc7, 0xc7, 0xcf, 0xcf, 0xdf, 0xdb, 0xfb, 0xf3, 0xf3, 0xe3, 0xe3, 0x00 },
   { 0x00, 0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xe7, 0x7e, 0x00 },
   { 0x00, 0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe, 0x00 },
   { 0x00, 0x00, 0x00, 0x3f, 0x6e, 0xdf, 0xdb, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x66, 0x3c, 0x00 },
   { 0x00, 0x00, 0x00, 0xc3, 0xc6, 0xcc, 0xd8, 0xf0, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe, 0x00 },
   { 0x00, 0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0x7e, 0xe0, 0xc0, 0xc0, 0xe7, 0x7e, 0x00 },
   { 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xff, 0x00 },
   { 0x00, 0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x00 },
   { 0x00, 0x00, 0x00, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x00 },
   { 0x00, 0x00, 0x00, 0xc3, 0xe7, 0xff, 0xff, 0xdb, 0xdb, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x00 },
   { 0x00, 0x00, 0x00, 0xc3, 0x66, 0x66, 0x3c, 0x3c, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3, 0x00 },
   { 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3, 0x00 },
   { 0x00, 0x00, 0x00, 0xff, 0xc0, 0xc0, 0x60, 0x30, 0x7e, 0x0c, 0x06, 0x03, 0x03, 0xff, 0x00 },
   { 0x00, 0x00, 0x00, 0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3c, 0x00 },
   { 0x00, 0x00, 0x03, 0x03, 0x06, 0x06, 0x0c, 0x0c, 0x18, 0x18, 0x30, 0x30, 0x60, 0x60, 0x00 },
   { 0x00, 0x00, 0x00, 0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c, 0x00 },
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0x66, 0x3c, 0x18, 0x00 },
   { 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x38, 0x30, 0x70, 0x00 },
   { 0x00, 0x00, 0x00, 0x7f, 0xc3, 0xc3, 0x7f, 0x03, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00 },
   { 0x00, 0x00, 0x00, 0xfe, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0x00 },
   { 0x00, 0x00, 0x00, 0x7e, 0xc3, 0xc0, 0xc0, 0xc0, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00 },
   { 0x00, 0x00, 0x00, 0x7f, 0xc3, 0xc3, 0xc3, 0xc3, 0x7f, 0x03, 0x03, 0x03, 0x03, 0x03, 0x00 },
   { 0x00, 0x00, 0x00, 0x7f, 0xc0, 0xc0, 0xfe, 0xc3, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00 },
   { 0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x33, 0x1e, 0x00 },
   { 0x00, 0x7e, 0xc3, 0x03, 0x03, 0x7f, 0xc3, 0xc3, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00 },
   { 0x00, 0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0, 0x00 },
   { 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00 },
   { 0x00, 0x38, 0x6c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x00, 0x00, 0x0c, 0x00, 0x00 },
   { 0x00, 0x00, 0x00, 0xc6, 0xcc, 0xf8, 0xf0, 0xd8, 0xcc, 0xc6, 0xc0, 0xc0, 0xc0, 0xc0, 0x00 },
   { 0x00, 0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00 },
   { 0x00, 0x00, 0x00, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00 },
   { 0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00 },
   { 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00 },
   { 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00 },
   { 0x00, 0x03, 0x03, 0x03, 0x7f, 0xc3, 0xc3, 0xc3, 0xc3, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00 },
   { 0x00, 0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xe0, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00 },
   { 0x00, 0x00, 0x00, 0xfe, 0x03, 0x03, 0x7e, 0xc0, 0xc0, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00 },
   { 0x00, 0x00, 0x00, 0x1c, 0x36, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x00, 0x00 },
   { 0x00, 0x00, 0x00, 0x7e, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00, 0x00 },
   { 0x00, 0x00, 0x00, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00, 0x00 },
   { 0x00, 0x00, 0x00, 0xc3, 0xe7, 0xff, 0xdb, 0xc3, 0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00, 0x00 },
   { 0x00, 0x00, 0x00, 0xc3, 0x66, 0x3c, 0x18, 0x3c, 0x66, 0xc3, 0x00, 0x00, 0x00, 0x00, 0x00 },
   { 0x00, 0xc0, 0x60, 0x60, 0x30, 0x18, 0x3c, 0x66, 0x66, 0xc3, 0x00, 0x00, 0x00, 0x00, 0x00 },
   { 0x00, 0x00, 0x00, 0xff, 0x60, 0x30, 0x18, 0x0c, 0x06, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00 },
   { 0x00, 0x00, 0x00, 0x0f, 0x18, 0x18, 0x18, 0x38, 0xf0, 0x38, 0x18, 0x18, 0x18, 0x0f, 0x00 },
   { 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00 },
   { 0x00, 0x00, 0x00, 0xf0, 0x18, 0x18, 0x18, 0x1c, 0x0f, 0x1c, 0x18, 0x18, 0x18, 0xf0, 0x00 },
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x8f, 0xf1, 0x60, 0x00, 0x00, 0x00, 0x00 }  // :126
};
